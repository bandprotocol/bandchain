// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: x/oracle/types/types.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResolveStatus encodes the status of an oracle request.
type ResolveStatus int32

const (
	// Open - the request is not yet resolved.
	ResolveStatus_Open ResolveStatus = 0
	// Success - the request has been resolved successfully with no errors.
	ResolveStatus_Success ResolveStatus = 1
	// Failure - an error occured during the request's resolve call.
	ResolveStatus_Failure ResolveStatus = 2
	// Expired - the request does not get enough reports from validator within the timeframe.
	ResolveStatus_Expired ResolveStatus = 3
)

var ResolveStatus_name = map[int32]string{
	0: "Open",
	1: "Success",
	2: "Failure",
	3: "Expired",
}

var ResolveStatus_value = map[string]int32{
	"Open":    0,
	"Success": 1,
	"Failure": 2,
	"Expired": 3,
}

func (x ResolveStatus) String() string {
	return proto.EnumName(ResolveStatus_name, int32(x))
}

func (ResolveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{0}
}

// MsgRequestData is a message for sending a data oracle request.
type MsgRequestData struct {
	// OracleScriptID is the identifier of the oracle script to call.
	OracleScriptID OracleScriptID `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the OBI encoded call parameters to the oracle script.
	Calldata []byte `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators to perform the oracle task.
	AskCount uint64 `protobuf:"varint,3,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators sufficient to resolve the tasks.
	MinCount uint64 `protobuf:"varint,4,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// ClientID is the client-provided unique identifier to tracking the request.
	ClientID string `protobuf:"bytes,5,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// Sender is the sender of this message.
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,6,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgRequestData) Reset()         { *m = MsgRequestData{} }
func (m *MsgRequestData) String() string { return proto.CompactTextString(m) }
func (*MsgRequestData) ProtoMessage()    {}
func (*MsgRequestData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{0}
}
func (m *MsgRequestData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestData.Merge(m, src)
}
func (m *MsgRequestData) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestData proto.InternalMessageInfo

func (m *MsgRequestData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *MsgRequestData) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *MsgRequestData) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *MsgRequestData) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *MsgRequestData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *MsgRequestData) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgReportData is a message for reporting to a data request by a validator.
type MsgReportData struct {
	// RequestID is the identifier of the request to report to.
	RequestID RequestID `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// RawReports is the list of report information for each of the request's external ID.
	RawReports []RawReport `protobuf:"bytes,2,rep,name=raw_reports,json=rawReports,proto3" json:"raw_reports"`
	// Validator is the address of the validator that owns this report.
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,3,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	// Reporter is the message signer who submits this report transaction for the validator.
	Reporter github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,4,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgReportData) Reset()         { *m = MsgReportData{} }
func (m *MsgReportData) String() string { return proto.CompactTextString(m) }
func (*MsgReportData) ProtoMessage()    {}
func (*MsgReportData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{1}
}
func (m *MsgReportData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportData.Merge(m, src)
}
func (m *MsgReportData) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportData proto.InternalMessageInfo

func (m *MsgReportData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *MsgReportData) GetRawReports() []RawReport {
	if m != nil {
		return m.RawReports
	}
	return nil
}

func (m *MsgReportData) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgReportData) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// MsgCreateDataSource is a message for creating a new data source.
type MsgCreateDataSource struct {
	// Owner is the address who is allowed to make further changes to the data source.
	Owner github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	// Name is the name of this data source (optional).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is the description of this data source (optional).
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Executable is the executable script or binary to be run by validators upon execution.
	Executable []byte `protobuf:"bytes,4,opt,name=executable,proto3" json:"executable,omitempty"`
	// Sender is the signer of this message.
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgCreateDataSource) Reset()         { *m = MsgCreateDataSource{} }
func (m *MsgCreateDataSource) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDataSource) ProtoMessage()    {}
func (*MsgCreateDataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{2}
}
func (m *MsgCreateDataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDataSource.Merge(m, src)
}
func (m *MsgCreateDataSource) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDataSource.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDataSource proto.InternalMessageInfo

func (m *MsgCreateDataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgCreateDataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateDataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateDataSource) GetExecutable() []byte {
	if m != nil {
		return m.Executable
	}
	return nil
}

func (m *MsgCreateDataSource) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgEditDataSource is a message for editing an existing data source.
type MsgEditDataSource struct {
	// DataSourceID is the unique identifier of the data source to be edited.
	DataSourceID DataSourceID `protobuf:"varint,1,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	// Owner is the new address who is allowed to make further changes to the data source.
	Owner github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	// Name is the name of this data source (optional).
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description is the description of this data source (optional).
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Executable is the executable script or binary to be run by validators upon execution.
	Executable []byte `protobuf:"bytes,5,opt,name=executable,proto3" json:"executable,omitempty"`
	// Sender is the signer of this message. Must be the current data source's owner.
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,6,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgEditDataSource) Reset()         { *m = MsgEditDataSource{} }
func (m *MsgEditDataSource) String() string { return proto.CompactTextString(m) }
func (*MsgEditDataSource) ProtoMessage()    {}
func (*MsgEditDataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{3}
}
func (m *MsgEditDataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditDataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditDataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditDataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditDataSource.Merge(m, src)
}
func (m *MsgEditDataSource) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditDataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditDataSource.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditDataSource proto.InternalMessageInfo

func (m *MsgEditDataSource) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *MsgEditDataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgEditDataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgEditDataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgEditDataSource) GetExecutable() []byte {
	if m != nil {
		return m.Executable
	}
	return nil
}

func (m *MsgEditDataSource) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgCreateOracleScript is a message for creating an oracle script.
type MsgCreateOracleScript struct {
	// Owner is the address who is allowed to make further changes to the oracle script.
	Owner github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	// Name is the name of this oracle script (optional).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is the description of this oracle script (optional).
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Code is the oracle WebAssembly binary code. Can be raw of gzip compressed.
	Code []byte `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	// Schema is the OBI schema of this oracle script (optional).
	Schema string `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	// SourceCodeURL is the absolute URI to the script's source code (optional).
	SourceCodeURL string `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
	// Sender is the signer of this message.
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgCreateOracleScript) Reset()         { *m = MsgCreateOracleScript{} }
func (m *MsgCreateOracleScript) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOracleScript) ProtoMessage()    {}
func (*MsgCreateOracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{4}
}
func (m *MsgCreateOracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOracleScript.Merge(m, src)
}
func (m *MsgCreateOracleScript) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOracleScript proto.InternalMessageInfo

func (m *MsgCreateOracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgCreateOracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateOracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateOracleScript) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *MsgCreateOracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *MsgCreateOracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

func (m *MsgCreateOracleScript) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgEditOracleScript is a message for editing an existing oracle script.
type MsgEditOracleScript struct {
	// OracleScriptID is the unique identifier of the oracle script to be edited.
	OracleScriptID OracleScriptID `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Owner is new the address who is allowed to make further changes to the oracle script.
	Owner github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	// Name is the name of this oracle script (optional).
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description is the description of this oracle script (optional).
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Code is the oracle WebAssembly binary code. Can be raw of gzip compressed.
	Code []byte `protobuf:"bytes,5,opt,name=code,proto3" json:"code,omitempty"`
	// Schema is the OBI schema of this oracle script (optional).
	Schema string `protobuf:"bytes,6,opt,name=schema,proto3" json:"schema,omitempty"`
	// SourceCodeURL is the absolute URI to the script's source code (optional).
	SourceCodeURL string `protobuf:"bytes,7,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
	// Sender is the signer of this message. Must be the current oracle script's owner.
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,8,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
}

func (m *MsgEditOracleScript) Reset()         { *m = MsgEditOracleScript{} }
func (m *MsgEditOracleScript) String() string { return proto.CompactTextString(m) }
func (*MsgEditOracleScript) ProtoMessage()    {}
func (*MsgEditOracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{5}
}
func (m *MsgEditOracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditOracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditOracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditOracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditOracleScript.Merge(m, src)
}
func (m *MsgEditOracleScript) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditOracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditOracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditOracleScript proto.InternalMessageInfo

func (m *MsgEditOracleScript) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *MsgEditOracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *MsgEditOracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgEditOracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgEditOracleScript) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *MsgEditOracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *MsgEditOracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

func (m *MsgEditOracleScript) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MsgEditOracleScript is a message for activating a validator to become an oracle provider.
type MsgActivate struct {
	// Validator is the signer of this message and the validator to be activated.
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
}

func (m *MsgActivate) Reset()         { *m = MsgActivate{} }
func (m *MsgActivate) String() string { return proto.CompactTextString(m) }
func (*MsgActivate) ProtoMessage()    {}
func (*MsgActivate) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{6}
}
func (m *MsgActivate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivate.Merge(m, src)
}
func (m *MsgActivate) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivate proto.InternalMessageInfo

func (m *MsgActivate) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

// MsgAddReporter is a message for adding a new reporter for a validator.
type MsgAddReporter struct {
	// Validator is the validator that wishes to add a new reporter. This is the signer.
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	// Reporter is the address to be added as a reporter to the validator.
	Reporter github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgAddReporter) Reset()         { *m = MsgAddReporter{} }
func (m *MsgAddReporter) String() string { return proto.CompactTextString(m) }
func (*MsgAddReporter) ProtoMessage()    {}
func (*MsgAddReporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{7}
}
func (m *MsgAddReporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddReporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddReporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddReporter.Merge(m, src)
}
func (m *MsgAddReporter) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddReporter) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddReporter.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddReporter proto.InternalMessageInfo

func (m *MsgAddReporter) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgAddReporter) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// MsgAddReporter is a message for removing an existing reporter from a validator.
type MsgRemoveReporter struct {
	// Validator is the validator that wishes to remove an existing reporter. This is the signer.
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	// Reporter is the address to be removed from being the validators' reporter.
	Reporter github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=reporter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"reporter,omitempty"`
}

func (m *MsgRemoveReporter) Reset()         { *m = MsgRemoveReporter{} }
func (m *MsgRemoveReporter) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveReporter) ProtoMessage()    {}
func (*MsgRemoveReporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{8}
}
func (m *MsgRemoveReporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveReporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveReporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveReporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveReporter.Merge(m, src)
}
func (m *MsgRemoveReporter) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveReporter) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveReporter.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveReporter proto.InternalMessageInfo

func (m *MsgRemoveReporter) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *MsgRemoveReporter) GetReporter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Reporter
	}
	return nil
}

// DataSource is the data structure for storing data sources in the storage.
type DataSource struct {
	Owner       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name        string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Filename    string                                        `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (m *DataSource) Reset()         { *m = DataSource{} }
func (m *DataSource) String() string { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()    {}
func (*DataSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{9}
}
func (m *DataSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSource.Merge(m, src)
}
func (m *DataSource) XXX_Size() int {
	return m.Size()
}
func (m *DataSource) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSource.DiscardUnknown(m)
}

var xxx_messageInfo_DataSource proto.InternalMessageInfo

func (m *DataSource) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DataSource) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

// OracleScript is the data structure for storing oracle scripts in the storage.
type OracleScript struct {
	Owner         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
	Name          string                                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                                        `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Filename      string                                        `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	Schema        string                                        `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	SourceCodeURL string                                        `protobuf:"bytes,6,opt,name=source_code_url,json=sourceCodeUrl,proto3" json:"source_code_url,omitempty"`
}

func (m *OracleScript) Reset()         { *m = OracleScript{} }
func (m *OracleScript) String() string { return proto.CompactTextString(m) }
func (*OracleScript) ProtoMessage()    {}
func (*OracleScript) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{10}
}
func (m *OracleScript) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleScript) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleScript.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleScript) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleScript.Merge(m, src)
}
func (m *OracleScript) XXX_Size() int {
	return m.Size()
}
func (m *OracleScript) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleScript.DiscardUnknown(m)
}

var xxx_messageInfo_OracleScript proto.InternalMessageInfo

func (m *OracleScript) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *OracleScript) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OracleScript) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OracleScript) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *OracleScript) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *OracleScript) GetSourceCodeURL() string {
	if m != nil {
		return m.SourceCodeURL
	}
	return ""
}

// RawRequest is the data structure for storing raw requests in the storage.
type RawRequest struct {
	ExternalID   ExternalID   `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	DataSourceID DataSourceID `protobuf:"varint,2,opt,name=data_source_id,json=dataSourceId,proto3,casttype=DataSourceID" json:"data_source_id,omitempty"`
	Calldata     []byte       `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
}

func (m *RawRequest) Reset()         { *m = RawRequest{} }
func (m *RawRequest) String() string { return proto.CompactTextString(m) }
func (*RawRequest) ProtoMessage()    {}
func (*RawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{11}
}
func (m *RawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRequest.Merge(m, src)
}
func (m *RawRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawRequest proto.InternalMessageInfo

func (m *RawRequest) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawRequest) GetDataSourceID() DataSourceID {
	if m != nil {
		return m.DataSourceID
	}
	return 0
}

func (m *RawRequest) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

// RawRequest is the data structure for storing raw reporter in the storage.
type RawReport struct {
	ExternalID ExternalID `protobuf:"varint,1,opt,name=external_id,json=externalId,proto3,casttype=ExternalID" json:"external_id,omitempty"`
	ExitCode   uint32     `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Data       []byte     `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawReport) Reset()         { *m = RawReport{} }
func (m *RawReport) String() string { return proto.CompactTextString(m) }
func (*RawReport) ProtoMessage()    {}
func (*RawReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{12}
}
func (m *RawReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawReport.Merge(m, src)
}
func (m *RawReport) XXX_Size() int {
	return m.Size()
}
func (m *RawReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RawReport.DiscardUnknown(m)
}

var xxx_messageInfo_RawReport proto.InternalMessageInfo

func (m *RawReport) GetExternalID() ExternalID {
	if m != nil {
		return m.ExternalID
	}
	return 0
}

func (m *RawReport) GetExitCode() uint32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *RawReport) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Request is the data structure for storing requests in the storage.
type Request struct {
	OracleScriptID      OracleScriptID                                  `protobuf:"varint,1,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	Calldata            []byte                                          `protobuf:"bytes,2,opt,name=calldata,proto3" json:"calldata,omitempty"`
	RequestedValidators []github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,3,rep,name=requested_validators,json=requestedValidators,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"requested_validators,omitempty"`
	MinCount            uint64                                          `protobuf:"varint,4,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	RequestHeight       int64                                           `protobuf:"varint,5,opt,name=request_height,json=requestHeight,proto3" json:"request_height,omitempty"`
	RequestTime         time.Time                                       `protobuf:"bytes,6,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time"`
	ClientID            string                                          `protobuf:"bytes,7,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	RawRequests         []RawRequest                                    `protobuf:"bytes,8,rep,name=raw_requests,json=rawRequests,proto3" json:"raw_requests"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{13}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *Request) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *Request) GetRequestedValidators() []github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.RequestedValidators
	}
	return nil
}

func (m *Request) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *Request) GetRequestHeight() int64 {
	if m != nil {
		return m.RequestHeight
	}
	return 0
}

func (m *Request) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetRawRequests() []RawRequest {
	if m != nil {
		return m.RawRequests
	}
	return nil
}

// Report is the data structure for storing reports in the storage.
type Report struct {
	Validator       github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=validator,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator,omitempty"`
	InBeforeResolve bool                                          `protobuf:"varint,2,opt,name=in_before_resolve,json=inBeforeResolve,proto3" json:"in_before_resolve,omitempty"`
	RawReports      []RawReport                                   `protobuf:"bytes,3,rep,name=raw_reports,json=rawReports,proto3" json:"raw_reports"`
}

func (m *Report) Reset()         { *m = Report{} }
func (m *Report) String() string { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()    {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{14}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Report.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *Report) GetValidator() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *Report) GetInBeforeResolve() bool {
	if m != nil {
		return m.InBeforeResolve
	}
	return false
}

func (m *Report) GetRawReports() []RawReport {
	if m != nil {
		return m.RawReports
	}
	return nil
}

// OracleRequestPacketData encodes an oracle request sent from other blockchains to BandChain.
type OracleRequestPacketData struct {
	// ClientID is the unique identifier of this oracle request, as specified by the client.
	// This same unique ID will be sent back to the requester with the oracle response.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// OracleScriptID is the unique identifier of the oracle script to be executed.
	OracleScriptID OracleScriptID `protobuf:"varint,2,opt,name=oracle_script_id,json=oracleScriptId,proto3,casttype=OracleScriptID" json:"oracle_script_id,omitempty"`
	// Calldata is the calldata bytes available for oracle executor to read.
	Calldata []byte `protobuf:"bytes,3,opt,name=calldata,proto3" json:"calldata,omitempty"`
	// AskCount is the number of validators that are requested to respond to this oracle request.
	// Higher value means more security, at a higher gas cost.
	AskCount uint64 `protobuf:"varint,4,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty"`
	// MinCount is the minimum number of validators necessary for the request to proceed to the
	// execution phase. Higher value means more security, at the cost of liveness.
	MinCount uint64 `protobuf:"varint,5,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
}

func (m *OracleRequestPacketData) Reset()         { *m = OracleRequestPacketData{} }
func (m *OracleRequestPacketData) String() string { return proto.CompactTextString(m) }
func (*OracleRequestPacketData) ProtoMessage()    {}
func (*OracleRequestPacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{15}
}
func (m *OracleRequestPacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestPacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestPacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestPacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestPacketData.Merge(m, src)
}
func (m *OracleRequestPacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestPacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestPacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestPacketData proto.InternalMessageInfo

func (m *OracleRequestPacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleRequestPacketData) GetOracleScriptID() OracleScriptID {
	if m != nil {
		return m.OracleScriptID
	}
	return 0
}

func (m *OracleRequestPacketData) GetCalldata() []byte {
	if m != nil {
		return m.Calldata
	}
	return nil
}

func (m *OracleRequestPacketData) GetAskCount() uint64 {
	if m != nil {
		return m.AskCount
	}
	return 0
}

func (m *OracleRequestPacketData) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

// OracleResponsePacketData encodes an oracle response from BandChain to the requester.
type OracleResponsePacketData struct {
	// ClientID is the unique identifier matched with that of the oracle request packet.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// RequestID is BandChain's unique identifier for this oracle request.
	RequestID RequestID `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3,casttype=RequestID" json:"request_id,omitempty"`
	// AnsCount is the number of validators among to the asked validators that actually responded
	// to this oracle request prior to this oracle request being resolved.
	AnsCount uint64 `protobuf:"varint,3,opt,name=ans_count,json=ansCount,proto3" json:"ans_count,omitempty"`
	// RequestTime is the UNIX epoch time at which the request was sent to BandChain.
	RequestTime int64 `protobuf:"varint,4,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// ResolveTime is the UNIX epoch time at which the request was resolved to the final result.
	ResolveTime int64 `protobuf:"varint,5,opt,name=resolve_time,json=resolveTime,proto3" json:"resolve_time,omitempty"`
	// ResolveStatus is the status of this oracle request, which can be OK, FAILURE, or EXPIRED.
	ResolveStatus ResolveStatus `protobuf:"varint,6,opt,name=resolve_status,json=resolveStatus,proto3,enum=bandchain.chain.x.oracle.v1.ResolveStatus" json:"resolve_status,omitempty"`
	// Result is the final aggregated value only available if status if OK.
	Result []byte `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *OracleResponsePacketData) Reset()         { *m = OracleResponsePacketData{} }
func (m *OracleResponsePacketData) String() string { return proto.CompactTextString(m) }
func (*OracleResponsePacketData) ProtoMessage()    {}
func (*OracleResponsePacketData) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{16}
}
func (m *OracleResponsePacketData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleResponsePacketData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleResponsePacketData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleResponsePacketData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleResponsePacketData.Merge(m, src)
}
func (m *OracleResponsePacketData) XXX_Size() int {
	return m.Size()
}
func (m *OracleResponsePacketData) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleResponsePacketData.DiscardUnknown(m)
}

var xxx_messageInfo_OracleResponsePacketData proto.InternalMessageInfo

func (m *OracleResponsePacketData) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OracleResponsePacketData) GetRequestID() RequestID {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *OracleResponsePacketData) GetAnsCount() uint64 {
	if m != nil {
		return m.AnsCount
	}
	return 0
}

func (m *OracleResponsePacketData) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveTime() int64 {
	if m != nil {
		return m.ResolveTime
	}
	return 0
}

func (m *OracleResponsePacketData) GetResolveStatus() ResolveStatus {
	if m != nil {
		return m.ResolveStatus
	}
	return ResolveStatus_Open
}

func (m *OracleResponsePacketData) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// ValidatorStatus maintains whether a validator is an active oracle provider.
type ValidatorStatus struct {
	IsActive bool      `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	Since    time.Time `protobuf:"bytes,2,opt,name=since,proto3,stdtime" json:"since"`
}

func (m *ValidatorStatus) Reset()         { *m = ValidatorStatus{} }
func (m *ValidatorStatus) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatus) ProtoMessage()    {}
func (*ValidatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{17}
}
func (m *ValidatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatus.Merge(m, src)
}
func (m *ValidatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatus proto.InternalMessageInfo

func (m *ValidatorStatus) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ValidatorStatus) GetSince() time.Time {
	if m != nil {
		return m.Since
	}
	return time.Time{}
}

// Params is the data structure that keeps the parameters of the oracle module.
type Params struct {
	// MaxRawRequestCount is the maximum number of data source raw requests a request can make.
	MaxRawRequestCount uint64 `protobuf:"varint,1,opt,name=max_raw_request_count,json=maxRawRequestCount,proto3" json:"max_raw_request_count,omitempty"`
	// MaxAskCount is the maximum number of validators a request can target.
	MaxAskCount uint64 `protobuf:"varint,2,opt,name=max_ask_count,json=maxAskCount,proto3" json:"max_ask_count,omitempty"`
	// ExpirationBlockCount is the number of blocks a request stays valid before it gets
	// expired due to insufficient reports.
	ExpirationBlockCount uint64 `protobuf:"varint,3,opt,name=expiration_block_count,json=expirationBlockCount,proto3" json:"expiration_block_count,omitempty"`
	// BaseRequestGas is the base amount of Cosmos-SDK gas charged for an oracle request.
	BaseRequestGas uint64 `protobuf:"varint,4,opt,name=base_request_gas,json=baseRequestGas,proto3" json:"base_request_gas,omitempty"`
	// PerValidatorRequestGas is the amount of Cosmos-SDK gas charged per requested validator.
	PerValidatorRequestGas uint64 `protobuf:"varint,5,opt,name=per_validator_request_gas,json=perValidatorRequestGas,proto3" json:"per_validator_request_gas,omitempty"`
	// SamplingTryCount the number of validator sampling tries to pick the highest voting power
	// subset of validators to perform an oracle task.
	SamplingTryCount uint64 `protobuf:"varint,6,opt,name=sampling_try_count,json=samplingTryCount,proto3" json:"sampling_try_count,omitempty"`
	// OracleRewardPercentage is the percentage of block rewards allocated to active oracle validators.
	OracleRewardPercentage uint64 `protobuf:"varint,7,opt,name=oracle_reward_percentage,json=oracleRewardPercentage,proto3" json:"oracle_reward_percentage,omitempty"`
	// InactivePenaltyDuration is the duration period where a validator cannot activate back
	// after missing an oracle report.
	InactivePenaltyDuration uint64 `protobuf:"varint,8,opt,name=inactive_penalty_duration,json=inactivePenaltyDuration,proto3" json:"inactive_penalty_duration,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_53e65fd95a58412c, []int{18}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxRawRequestCount() uint64 {
	if m != nil {
		return m.MaxRawRequestCount
	}
	return 0
}

func (m *Params) GetMaxAskCount() uint64 {
	if m != nil {
		return m.MaxAskCount
	}
	return 0
}

func (m *Params) GetExpirationBlockCount() uint64 {
	if m != nil {
		return m.ExpirationBlockCount
	}
	return 0
}

func (m *Params) GetBaseRequestGas() uint64 {
	if m != nil {
		return m.BaseRequestGas
	}
	return 0
}

func (m *Params) GetPerValidatorRequestGas() uint64 {
	if m != nil {
		return m.PerValidatorRequestGas
	}
	return 0
}

func (m *Params) GetSamplingTryCount() uint64 {
	if m != nil {
		return m.SamplingTryCount
	}
	return 0
}

func (m *Params) GetOracleRewardPercentage() uint64 {
	if m != nil {
		return m.OracleRewardPercentage
	}
	return 0
}

func (m *Params) GetInactivePenaltyDuration() uint64 {
	if m != nil {
		return m.InactivePenaltyDuration
	}
	return 0
}

func init() {
	proto.RegisterEnum("bandchain.chain.x.oracle.v1.ResolveStatus", ResolveStatus_name, ResolveStatus_value)
	proto.RegisterType((*MsgRequestData)(nil), "bandchain.chain.x.oracle.v1.MsgRequestData")
	proto.RegisterType((*MsgReportData)(nil), "bandchain.chain.x.oracle.v1.MsgReportData")
	proto.RegisterType((*MsgCreateDataSource)(nil), "bandchain.chain.x.oracle.v1.MsgCreateDataSource")
	proto.RegisterType((*MsgEditDataSource)(nil), "bandchain.chain.x.oracle.v1.MsgEditDataSource")
	proto.RegisterType((*MsgCreateOracleScript)(nil), "bandchain.chain.x.oracle.v1.MsgCreateOracleScript")
	proto.RegisterType((*MsgEditOracleScript)(nil), "bandchain.chain.x.oracle.v1.MsgEditOracleScript")
	proto.RegisterType((*MsgActivate)(nil), "bandchain.chain.x.oracle.v1.MsgActivate")
	proto.RegisterType((*MsgAddReporter)(nil), "bandchain.chain.x.oracle.v1.MsgAddReporter")
	proto.RegisterType((*MsgRemoveReporter)(nil), "bandchain.chain.x.oracle.v1.MsgRemoveReporter")
	proto.RegisterType((*DataSource)(nil), "bandchain.chain.x.oracle.v1.DataSource")
	proto.RegisterType((*OracleScript)(nil), "bandchain.chain.x.oracle.v1.OracleScript")
	proto.RegisterType((*RawRequest)(nil), "bandchain.chain.x.oracle.v1.RawRequest")
	proto.RegisterType((*RawReport)(nil), "bandchain.chain.x.oracle.v1.RawReport")
	proto.RegisterType((*Request)(nil), "bandchain.chain.x.oracle.v1.Request")
	proto.RegisterType((*Report)(nil), "bandchain.chain.x.oracle.v1.Report")
	proto.RegisterType((*OracleRequestPacketData)(nil), "bandchain.chain.x.oracle.v1.OracleRequestPacketData")
	proto.RegisterType((*OracleResponsePacketData)(nil), "bandchain.chain.x.oracle.v1.OracleResponsePacketData")
	proto.RegisterType((*ValidatorStatus)(nil), "bandchain.chain.x.oracle.v1.ValidatorStatus")
	proto.RegisterType((*Params)(nil), "bandchain.chain.x.oracle.v1.Params")
}

func init() { proto.RegisterFile("x/oracle/types/types.proto", fileDescriptor_53e65fd95a58412c) }

var fileDescriptor_53e65fd95a58412c = []byte{
	// 1500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x3b, 0x6c, 0x1c, 0x55,
	0x17, 0xf6, 0xcc, 0xec, 0xae, 0x67, 0xcf, 0xda, 0x8e, 0x33, 0x49, 0x9c, 0x8d, 0xfd, 0xcb, 0xbb,
	0x7f, 0xf4, 0xff, 0xc1, 0x44, 0x64, 0x57, 0x09, 0x08, 0x11, 0x4b, 0x48, 0x78, 0xed, 0x24, 0x58,
	0xc2, 0xc4, 0x8c, 0x43, 0x0a, 0x9a, 0xd1, 0xdd, 0x99, 0x9b, 0xf5, 0xc8, 0xf3, 0xe2, 0xde, 0x59,
	0x7b, 0x5d, 0x82, 0x44, 0x9f, 0x92, 0x82, 0x22, 0x25, 0x0d, 0x0d, 0x12, 0x48, 0x54, 0xb4, 0x91,
	0x90, 0x50, 0x0a, 0x0a, 0x44, 0xb1, 0xa0, 0x4d, 0x83, 0x44, 0x43, 0x9d, 0x0a, 0xdd, 0xc7, 0xbc,
	0x42, 0xd8, 0x24, 0xce, 0x42, 0x42, 0x63, 0xcf, 0x79, 0xdc, 0x99, 0x73, 0xbf, 0xf3, 0x9d, 0x73,
	0xef, 0x59, 0x58, 0x1c, 0xb4, 0x43, 0x82, 0x6c, 0x0f, 0xb7, 0xe3, 0xc3, 0x08, 0x53, 0xf1, 0xb7,
	0x15, 0x91, 0x30, 0x0e, 0x8d, 0xa5, 0x2e, 0x0a, 0x1c, 0x7b, 0x17, 0xb9, 0x41, 0x4b, 0xfc, 0x1d,
	0xb4, 0x84, 0x6f, 0x6b, 0xff, 0xe2, 0xe2, 0xb9, 0x78, 0xd7, 0x25, 0x8e, 0x15, 0x21, 0x12, 0x1f,
	0xb6, 0xb9, 0x7f, 0xbb, 0x17, 0xf6, 0xc2, 0xec, 0x49, 0xbc, 0x64, 0xb1, 0xd1, 0x0b, 0xc3, 0x9e,
	0x87, 0x85, 0x4b, 0xb7, 0x7f, 0xab, 0x1d, 0xbb, 0x3e, 0xa6, 0x31, 0xf2, 0x23, 0xe1, 0x70, 0xf6,
	0x4b, 0x15, 0xe6, 0xb6, 0x68, 0xcf, 0xc4, 0x1f, 0xf6, 0x31, 0x8d, 0x37, 0x50, 0x8c, 0x8c, 0x77,
	0x61, 0x5e, 0x7c, 0xc8, 0xa2, 0x36, 0x71, 0xa3, 0xd8, 0x72, 0x9d, 0xba, 0xd2, 0x54, 0x56, 0xb4,
	0xce, 0xff, 0x46, 0xc3, 0xc6, 0xdc, 0x75, 0x6e, 0xdb, 0xe1, 0xa6, 0xcd, 0x8d, 0x07, 0x7f, 0xd2,
	0x98, 0x73, 0x61, 0x5e, 0x76, 0x8c, 0x45, 0xd0, 0x6d, 0xe4, 0x79, 0x0e, 0x8a, 0x51, 0x5d, 0x6d,
	0x2a, 0x2b, 0x33, 0x66, 0x2a, 0x1b, 0x4b, 0x50, 0x45, 0x74, 0xcf, 0xb2, 0xc3, 0x7e, 0x10, 0xd7,
	0xb5, 0xa6, 0xb2, 0x52, 0x32, 0x75, 0x44, 0xf7, 0xd6, 0x99, 0xcc, 0x8c, 0xbe, 0x1b, 0x48, 0x63,
	0x49, 0x18, 0x7d, 0x37, 0x10, 0xc6, 0x97, 0xa1, 0x6a, 0x7b, 0x2e, 0x0e, 0x78, 0x78, 0xe5, 0xa6,
	0xb2, 0x52, 0xed, 0xcc, 0x8c, 0x86, 0x0d, 0x7d, 0x9d, 0x2b, 0x37, 0x37, 0x4c, 0x5d, 0x98, 0x37,
	0x1d, 0x63, 0x13, 0x2a, 0x14, 0x07, 0x0e, 0x26, 0xf5, 0x0a, 0xfb, 0x7c, 0xe7, 0xe2, 0x83, 0x61,
	0xe3, 0x42, 0xcf, 0x8d, 0x77, 0xfb, 0xdd, 0x96, 0x1d, 0xfa, 0x6d, 0x3b, 0xa4, 0x7e, 0x48, 0xe5,
	0xbf, 0x0b, 0xd4, 0xd9, 0x93, 0x79, 0x58, 0xb3, 0xed, 0x35, 0xc7, 0x21, 0x98, 0x52, 0x53, 0xbe,
	0x60, 0xb5, 0xf4, 0xeb, 0x9d, 0x86, 0x72, 0xf6, 0x5b, 0x15, 0x66, 0x39, 0x68, 0x51, 0x48, 0x04,
	0x66, 0x97, 0x01, 0x88, 0x80, 0x30, 0x43, 0x6b, 0x71, 0x34, 0x6c, 0x54, 0x25, 0xb0, 0x1c, 0xa8,
	0x4c, 0x30, 0xab, 0xd2, 0x7b, 0xd3, 0x31, 0xb6, 0xa0, 0x46, 0xd0, 0x81, 0x45, 0xf8, 0xcb, 0x68,
	0x5d, 0x6d, 0x6a, 0x2b, 0xb5, 0x4b, 0xe7, 0x5a, 0x63, 0xb2, 0xdf, 0x32, 0xd1, 0x81, 0xf8, 0x76,
	0xa7, 0x74, 0x77, 0xd8, 0x98, 0x32, 0x81, 0x24, 0x0a, 0x6a, 0x5c, 0x87, 0xea, 0x3e, 0xf2, 0x5c,
	0x07, 0xc5, 0x21, 0xe1, 0x88, 0x3e, 0xf9, 0x7e, 0x6f, 0x22, 0x2f, 0xd9, 0x6f, 0xf6, 0x0e, 0x63,
	0x0b, 0x74, 0x11, 0x1b, 0x26, 0x3c, 0x09, 0x47, 0xc2, 0x2f, 0x7d, 0x85, 0x44, 0xf0, 0x13, 0x15,
	0x4e, 0x6c, 0xd1, 0xde, 0x3a, 0xc1, 0x28, 0xc6, 0x0c, 0xc1, 0x9d, 0xb0, 0x4f, 0x6c, 0x6c, 0x5c,
	0x83, 0x72, 0x78, 0x10, 0x60, 0xc2, 0x21, 0x3c, 0xd2, 0x97, 0xc4, 0x7a, 0xc3, 0x80, 0x52, 0x80,
	0x7c, 0xcc, 0x09, 0x57, 0x35, 0xf9, 0xb3, 0xd1, 0x84, 0x9a, 0x83, 0x05, 0xa7, 0xdd, 0x30, 0xe0,
	0xe0, 0x54, 0xcd, 0xbc, 0xca, 0x58, 0x06, 0xc0, 0x03, 0x6c, 0xf7, 0x63, 0xd4, 0xf5, 0xb0, 0xd8,
	0xad, 0x99, 0xd3, 0xe4, 0x98, 0x54, 0x9e, 0x0c, 0x93, 0xbe, 0x53, 0xe1, 0xf8, 0x16, 0xed, 0x5d,
	0x71, 0xdc, 0x38, 0x87, 0xc2, 0x55, 0x98, 0x63, 0xd5, 0x61, 0x51, 0x2e, 0x66, 0x8c, 0x6a, 0x8e,
	0x86, 0x8d, 0x99, 0xcc, 0x8f, 0x93, 0xaa, 0x20, 0x9b, 0x33, 0x4e, 0x26, 0x39, 0x19, 0x9a, 0xea,
	0x84, 0xd0, 0xd4, 0xfe, 0x1a, 0xcd, 0xd2, 0xe3, 0xd0, 0x2c, 0x8f, 0x41, 0x73, 0x42, 0x75, 0xf9,
	0xbd, 0x0a, 0xa7, 0x52, 0x56, 0xe5, 0xbb, 0xd2, 0xf3, 0xe6, 0x95, 0x01, 0x25, 0x3b, 0x74, 0x12,
	0x46, 0xf1, 0x67, 0x63, 0x01, 0x2a, 0xd4, 0xde, 0xc5, 0x3e, 0x12, 0xdd, 0xcb, 0x94, 0x92, 0x71,
	0x19, 0x8e, 0xc9, 0xbc, 0x33, 0x37, 0xab, 0x4f, 0x3c, 0x0e, 0x4f, 0xb5, 0x73, 0x7c, 0x34, 0x6c,
	0xcc, 0x8a, 0xdc, 0xae, 0x87, 0x0e, 0x7e, 0xdf, 0x7c, 0xc7, 0x9c, 0xa5, 0x99, 0x48, 0xbc, 0x1c,
	0xa0, 0xd3, 0x93, 0x01, 0xf4, 0x33, 0x8d, 0x97, 0x29, 0xa3, 0x67, 0x01, 0xce, 0x49, 0x1f, 0x11,
	0xcf, 0x99, 0xa8, 0x49, 0x7a, 0xca, 0x8f, 0x4c, 0x4f, 0xe5, 0x71, 0xe9, 0x99, 0x7e, 0xea, 0xf4,
	0xe8, 0x93, 0x49, 0x8f, 0x03, 0xb5, 0x2d, 0xda, 0x5b, 0xb3, 0x63, 0x77, 0x1f, 0xc5, 0xb8, 0xd8,
	0xfa, 0x95, 0x67, 0x6f, 0xfd, 0xf2, 0x2b, 0x5f, 0x2b, 0xfc, 0x8a, 0xb0, 0xe6, 0x38, 0xa6, 0x6c,
	0xe2, 0x13, 0xff, 0x52, 0xe1, 0x90, 0x51, 0x27, 0x75, 0xc8, 0x7c, 0xa3, 0xf0, 0xe6, 0x6a, 0x62,
	0x3f, 0xdc, 0xc7, 0xff, 0xb2, 0xd8, 0xbf, 0x50, 0x00, 0x5e, 0x9c, 0x73, 0x71, 0x11, 0xf4, 0x5b,
	0xae, 0x87, 0xf9, 0x4a, 0x51, 0x3f, 0xa9, 0x2c, 0xe3, 0xfd, 0x58, 0x85, 0x99, 0x17, 0xa9, 0xe3,
	0x8e, 0x89, 0xf8, 0x6f, 0xe8, 0xbc, 0x12, 0x84, 0xaf, 0x14, 0x00, 0x7e, 0x37, 0xe3, 0x77, 0x3b,
	0xe3, 0x4d, 0xa8, 0xe1, 0x41, 0x8c, 0x49, 0x80, 0xbc, 0xac, 0x41, 0xfe, 0x67, 0x34, 0x6c, 0xc0,
	0x15, 0xa9, 0xe6, 0xcd, 0x31, 0x27, 0xb1, 0xe3, 0x51, 0x3e, 0x3b, 0x8f, 0xb8, 0x05, 0xa8, 0x47,
	0xba, 0x05, 0xe4, 0xef, 0xdf, 0x5a, 0xf1, 0xfe, 0x2d, 0xe3, 0xfe, 0x48, 0x81, 0x6a, 0x7a, 0xa7,
	0x7c, 0xd6, 0xb0, 0x97, 0xa0, 0x8a, 0x07, 0x6e, 0xcc, 0x31, 0xe4, 0x11, 0xcf, 0x9a, 0x3a, 0x53,
	0x30, 0xa8, 0x58, 0x32, 0x73, 0x71, 0x94, 0x72, 0x31, 0xfc, 0xa6, 0xc1, 0x74, 0x02, 0xdc, 0x3f,
	0x39, 0x81, 0x38, 0x70, 0x52, 0xde, 0xc5, 0xb1, 0x63, 0xa5, 0x45, 0x4d, 0xeb, 0x5a, 0x53, 0x3b,
	0x5a, 0x67, 0x38, 0x91, 0xbe, 0xee, 0x66, 0xfa, 0xb6, 0xf1, 0xa3, 0xcc, 0xff, 0x61, 0x2e, 0x19,
	0x1e, 0x76, 0xb1, 0xdb, 0xdb, 0x8d, 0x39, 0x2f, 0x35, 0x73, 0x56, 0x6a, 0xdf, 0xe6, 0x4a, 0xe3,
	0x1a, 0xcc, 0x24, 0x6e, 0x6c, 0x8a, 0xe3, 0xdc, 0xac, 0x5d, 0x5a, 0x6c, 0x89, 0x11, 0xaf, 0x95,
	0x8c, 0x78, 0xad, 0x1b, 0xc9, 0x88, 0xd7, 0xd1, 0xd9, 0x74, 0x70, 0xfb, 0xe7, 0x86, 0x62, 0xd6,
	0xe4, 0x4a, 0x66, 0x2b, 0x8e, 0x4e, 0xd3, 0x63, 0x47, 0xa7, 0x6d, 0x98, 0x11, 0xc3, 0x09, 0x5f,
	0x4d, 0xeb, 0x3a, 0x9f, 0x4e, 0x5e, 0x7a, 0xfc, 0x74, 0xc2, 0xfd, 0xe5, 0x78, 0x52, 0x23, 0xa9,
	0x86, 0xca, 0x6c, 0xff, 0xa4, 0x40, 0x45, 0xd2, 0x6d, 0xe2, 0xfd, 0xf8, 0x3c, 0x1c, 0x77, 0x03,
	0xab, 0x8b, 0x6f, 0x85, 0x04, 0x5b, 0x04, 0xd3, 0xd0, 0xdb, 0x17, 0x44, 0xd4, 0xcd, 0x63, 0x6e,
	0xd0, 0xe1, 0x7a, 0x53, 0xa8, 0x1f, 0x1e, 0xbe, 0xb4, 0x67, 0x1b, 0xbe, 0xe4, 0xe6, 0x7e, 0x57,
	0xe0, 0xb4, 0x60, 0xa4, 0xdc, 0xf5, 0x36, 0xb2, 0xf7, 0xb0, 0x18, 0x14, 0x0b, 0xd8, 0x2b, 0x63,
	0xb1, 0x7f, 0x54, 0x15, 0xa8, 0x13, 0xaa, 0x02, 0x6d, 0xdc, 0x1c, 0x5e, 0x1a, 0x37, 0x87, 0x97,
	0x8b, 0xe4, 0x95, 0x5b, 0xfe, 0x41, 0x85, 0x7a, 0xb2, 0x65, 0x1a, 0x85, 0x01, 0xc5, 0x47, 0xdb,
	0x73, 0x71, 0x8e, 0x56, 0x9f, 0x66, 0x8e, 0x66, 0x5b, 0x08, 0xe8, 0x43, 0x3f, 0x25, 0x04, 0x54,
	0x6c, 0xe1, 0xbf, 0x0f, 0xd5, 0x4e, 0x89, 0x17, 0x58, 0xa1, 0x2a, 0xb8, 0x0b, 0x67, 0x85, 0x70,
	0x29, 0x27, 0x2e, 0x5c, 0xc7, 0x5d, 0xde, 0x63, 0x85, 0x2a, 0x5c, 0x68, 0x8c, 0xe2, 0x3e, 0xe5,
	0x35, 0x38, 0x77, 0xe9, 0xfc, 0x78, 0xc2, 0x88, 0x25, 0x3b, 0x7c, 0x05, 0x2b, 0xea, 0x9c, 0xc8,
	0xce, 0x22, 0x82, 0x69, 0xdf, 0x8b, 0xc5, 0x95, 0xdd, 0x94, 0x92, 0x84, 0x35, 0x82, 0x63, 0x69,
	0x13, 0x91, 0x0b, 0x96, 0xa0, 0xea, 0x52, 0x0b, 0xb1, 0x3b, 0x1f, 0xe6, 0x60, 0xea, 0xa6, 0xee,
	0x52, 0x7e, 0x07, 0xc4, 0xc6, 0x2a, 0x94, 0xa9, 0x1b, 0xd8, 0x82, 0xee, 0x4f, 0xda, 0x1b, 0xc4,
	0x12, 0xf9, 0xc5, 0xcf, 0x35, 0xa8, 0x6c, 0x23, 0x82, 0x7c, 0x6a, 0x5c, 0x84, 0x53, 0x3e, 0x1a,
	0x58, 0xb9, 0xfa, 0x97, 0xe0, 0x2a, 0x1c, 0x5c, 0xc3, 0x47, 0x83, 0xac, 0xd4, 0x05, 0xcc, 0x67,
	0x61, 0x96, 0x2d, 0xc9, 0xa8, 0xa4, 0x72, 0xd7, 0x9a, 0x8f, 0x06, 0x6b, 0x09, 0x9b, 0x5e, 0x83,
	0x05, 0x3c, 0x88, 0x5c, 0x82, 0xd8, 0x39, 0x6d, 0x75, 0xbd, 0xd0, 0x2e, 0xfe, 0xfe, 0x73, 0x32,
	0xb3, 0x76, 0x98, 0x51, 0xac, 0x5a, 0x81, 0xf9, 0x2e, 0xa2, 0x38, 0x8d, 0xa4, 0x87, 0xa8, 0xe4,
	0xe9, 0x1c, 0xd3, 0xcb, 0x28, 0xae, 0x21, 0x6a, 0x5c, 0x86, 0x33, 0x11, 0x26, 0x59, 0x2b, 0x2f,
	0x2c, 0x11, 0xec, 0x5d, 0x88, 0x30, 0x49, 0x71, 0xcd, 0x2d, 0x7d, 0x05, 0x0c, 0x8a, 0xfc, 0xc8,
	0x73, 0x83, 0x9e, 0x15, 0x93, 0x43, 0x19, 0x56, 0x85, 0xaf, 0x99, 0x4f, 0x2c, 0x37, 0xc8, 0xa1,
	0x08, 0xe9, 0x0d, 0xa8, 0xcb, 0xfa, 0x24, 0xf8, 0x00, 0x11, 0xc7, 0x8a, 0x30, 0xb1, 0x71, 0x10,
	0xa3, 0x1e, 0xe6, 0xc9, 0x2c, 0x99, 0x0b, 0xa1, 0x2c, 0x09, 0x66, 0xde, 0x4e, 0xad, 0xc6, 0x2a,
	0x9c, 0x71, 0x03, 0x91, 0x42, 0x2b, 0xc2, 0x01, 0xf2, 0xe2, 0x43, 0xcb, 0xe9, 0x8b, 0x3d, 0xf3,
	0xd9, 0xa0, 0x64, 0x9e, 0x4e, 0x1c, 0xb6, 0x85, 0x7d, 0x43, 0x9a, 0x57, 0xf5, 0x4f, 0xef, 0x34,
	0xa6, 0x58, 0xaa, 0xce, 0xbf, 0x05, 0xb3, 0x05, 0x6a, 0x19, 0x3a, 0x94, 0xae, 0x47, 0x38, 0x98,
	0x9f, 0x32, 0x6a, 0x30, 0xbd, 0xd3, 0xb7, 0x6d, 0x4c, 0xe9, 0xbc, 0xc2, 0x84, 0xab, 0xc8, 0xf5,
	0xfa, 0x04, 0xcf, 0xab, 0x4c, 0xb8, 0xc2, 0xf0, 0xc5, 0xce, 0xbc, 0xd6, 0xd9, 0xbe, 0x3b, 0x5a,
	0x56, 0xee, 0x8d, 0x96, 0x95, 0x5f, 0x46, 0xcb, 0xca, 0xed, 0xfb, 0xcb, 0x53, 0xf7, 0xee, 0x2f,
	0x4f, 0xfd, 0x78, 0x7f, 0x79, 0xea, 0x83, 0xd7, 0x73, 0xdd, 0x97, 0x71, 0x9b, 0x13, 0xc8, 0x0e,
	0xbd, 0x76, 0x4a, 0xf4, 0xb6, 0xf8, 0x5b, 0xfc, 0x01, 0xb3, 0x5b, 0xe1, 0x8e, 0xaf, 0xfe, 0x11,
	0x00, 0x00, 0xff, 0xff, 0x9a, 0x36, 0xe7, 0x80, 0xd9, 0x14, 0x00, 0x00,
}

func (this *MsgRequestData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgRequestData)
	if !ok {
		that2, ok := that.(MsgRequestData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgReportData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgReportData)
	if !ok {
		that2, ok := that.(MsgReportData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.RawReports) != len(that1.RawReports) {
		return false
	}
	for i := range this.RawReports {
		if !this.RawReports[i].Equal(&that1.RawReports[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *MsgCreateDataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgCreateDataSource)
	if !ok {
		that2, ok := that.(MsgCreateDataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Executable, that1.Executable) {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgEditDataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgEditDataSource)
	if !ok {
		that2, ok := that.(MsgEditDataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Executable, that1.Executable) {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgCreateOracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgCreateOracleScript)
	if !ok {
		that2, ok := that.(MsgCreateOracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgEditOracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgEditOracleScript)
	if !ok {
		that2, ok := that.(MsgEditOracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	if !bytes.Equal(this.Sender, that1.Sender) {
		return false
	}
	return true
}
func (this *MsgActivate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgActivate)
	if !ok {
		that2, ok := that.(MsgActivate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	return true
}
func (this *MsgAddReporter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgAddReporter)
	if !ok {
		that2, ok := that.(MsgAddReporter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *MsgRemoveReporter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgRemoveReporter)
	if !ok {
		that2, ok := that.(MsgRemoveReporter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if !bytes.Equal(this.Reporter, that1.Reporter) {
		return false
	}
	return true
}
func (this *DataSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSource)
	if !ok {
		that2, ok := that.(DataSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	return true
}
func (this *OracleScript) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleScript)
	if !ok {
		that2, ok := that.(OracleScript)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Owner, that1.Owner) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.SourceCodeURL != that1.SourceCodeURL {
		return false
	}
	return true
}
func (this *RawRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawRequest)
	if !ok {
		that2, ok := that.(RawRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.DataSourceID != that1.DataSourceID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	return true
}
func (this *RawReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawReport)
	if !ok {
		that2, ok := that.(RawReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExternalID != that1.ExternalID {
		return false
	}
	if this.ExitCode != that1.ExitCode {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if len(this.RequestedValidators) != len(that1.RequestedValidators) {
		return false
	}
	for i := range this.RequestedValidators {
		if !bytes.Equal(this.RequestedValidators[i], that1.RequestedValidators[i]) {
			return false
		}
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	if this.RequestHeight != that1.RequestHeight {
		return false
	}
	if !this.RequestTime.Equal(that1.RequestTime) {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if len(this.RawRequests) != len(that1.RawRequests) {
		return false
	}
	for i := range this.RawRequests {
		if !this.RawRequests[i].Equal(&that1.RawRequests[i]) {
			return false
		}
	}
	return true
}
func (this *Report) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Report)
	if !ok {
		that2, ok := that.(Report)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Validator, that1.Validator) {
		return false
	}
	if this.InBeforeResolve != that1.InBeforeResolve {
		return false
	}
	if len(this.RawReports) != len(that1.RawReports) {
		return false
	}
	for i := range this.RawReports {
		if !this.RawReports[i].Equal(&that1.RawReports[i]) {
			return false
		}
	}
	return true
}
func (this *OracleRequestPacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleRequestPacketData)
	if !ok {
		that2, ok := that.(OracleRequestPacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.OracleScriptID != that1.OracleScriptID {
		return false
	}
	if !bytes.Equal(this.Calldata, that1.Calldata) {
		return false
	}
	if this.AskCount != that1.AskCount {
		return false
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	return true
}
func (this *OracleResponsePacketData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OracleResponsePacketData)
	if !ok {
		that2, ok := that.(OracleResponsePacketData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AnsCount != that1.AnsCount {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.ResolveTime != that1.ResolveTime {
		return false
	}
	if this.ResolveStatus != that1.ResolveStatus {
		return false
	}
	if !bytes.Equal(this.Result, that1.Result) {
		return false
	}
	return true
}
func (this *ValidatorStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorStatus)
	if !ok {
		that2, ok := that.(ValidatorStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if !this.Since.Equal(that1.Since) {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRawRequestCount != that1.MaxRawRequestCount {
		return false
	}
	if this.MaxAskCount != that1.MaxAskCount {
		return false
	}
	if this.ExpirationBlockCount != that1.ExpirationBlockCount {
		return false
	}
	if this.BaseRequestGas != that1.BaseRequestGas {
		return false
	}
	if this.PerValidatorRequestGas != that1.PerValidatorRequestGas {
		return false
	}
	if this.SamplingTryCount != that1.SamplingTryCount {
		return false
	}
	if this.OracleRewardPercentage != that1.OracleRewardPercentage {
		return false
	}
	if this.InactivePenaltyDuration != that1.InactivePenaltyDuration {
		return false
	}
	return true
}
func (m *MsgRequestData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MinCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x20
	}
	if m.AskCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RawReports) > 0 {
		for iNdEx := len(m.RawReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RequestID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Executable) > 0 {
		i -= len(m.Executable)
		copy(dAtA[i:], m.Executable)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Executable)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditDataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditDataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditDataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Executable) > 0 {
		i -= len(m.Executable)
		copy(dAtA[i:], m.Executable)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Executable)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DataSourceID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateOracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEditOracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditOracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditOracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddReporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddReporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveReporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveReporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveReporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleScript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleScript) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleScript) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceCodeURL) > 0 {
		i -= len(m.SourceCodeURL)
		copy(dAtA[i:], m.SourceCodeURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCodeURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		i -= len(m.Schema)
		copy(dAtA[i:], m.Schema)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Schema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataSourceID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataSourceID))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExitCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ExternalID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExternalID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawRequests) > 0 {
		for iNdEx := len(m.RawRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x3a
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x32
	if m.RequestHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.MinCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RequestedValidators) > 0 {
		for iNdEx := len(m.RequestedValidators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedValidators[iNdEx])
			copy(dAtA[i:], m.RequestedValidators[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestedValidators[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x12
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawReports) > 0 {
		for iNdEx := len(m.RawReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InBeforeResolve {
		i--
		if m.InBeforeResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleRequestPacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestPacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestPacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x28
	}
	if m.AskCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AskCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Calldata) > 0 {
		i -= len(m.Calldata)
		copy(dAtA[i:], m.Calldata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Calldata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleScriptID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleScriptID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleResponsePacketData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleResponsePacketData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleResponsePacketData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResolveStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolveStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.ResolveTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResolveTime))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestTime))
		i--
		dAtA[i] = 0x20
	}
	if m.AnsCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Since, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Since):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTypes(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InactivePenaltyDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InactivePenaltyDuration))
		i--
		dAtA[i] = 0x40
	}
	if m.OracleRewardPercentage != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OracleRewardPercentage))
		i--
		dAtA[i] = 0x38
	}
	if m.SamplingTryCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SamplingTryCount))
		i--
		dAtA[i] = 0x30
	}
	if m.PerValidatorRequestGas != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PerValidatorRequestGas))
		i--
		dAtA[i] = 0x28
	}
	if m.BaseRequestGas != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BaseRequestGas))
		i--
		dAtA[i] = 0x20
	}
	if m.ExpirationBlockCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationBlockCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxAskCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAskCount))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRawRequestCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRawRequestCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRequestData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovTypes(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovTypes(uint64(m.MinCount))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgReportData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovTypes(uint64(m.RequestID))
	}
	if len(m.RawReports) > 0 {
		for _, e := range m.RawReports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateDataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgEditDataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSourceID != 0 {
		n += 1 + sovTypes(uint64(m.DataSourceID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Executable)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateOracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgEditOracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgActivate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgAddReporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgRemoveReporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DataSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OracleScript) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SourceCodeURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovTypes(uint64(m.ExternalID))
	}
	if m.DataSourceID != 0 {
		n += 1 + sovTypes(uint64(m.DataSourceID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RawReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalID != 0 {
		n += 1 + sovTypes(uint64(m.ExternalID))
	}
	if m.ExitCode != 0 {
		n += 1 + sovTypes(uint64(m.ExitCode))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RequestedValidators) > 0 {
		for _, b := range m.RequestedValidators {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MinCount != 0 {
		n += 1 + sovTypes(uint64(m.MinCount))
	}
	if m.RequestHeight != 0 {
		n += 1 + sovTypes(uint64(m.RequestHeight))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RawRequests) > 0 {
		for _, e := range m.RawRequests {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.InBeforeResolve {
		n += 2
	}
	if len(m.RawReports) > 0 {
		for _, e := range m.RawReports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OracleRequestPacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OracleScriptID != 0 {
		n += 1 + sovTypes(uint64(m.OracleScriptID))
	}
	l = len(m.Calldata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AskCount != 0 {
		n += 1 + sovTypes(uint64(m.AskCount))
	}
	if m.MinCount != 0 {
		n += 1 + sovTypes(uint64(m.MinCount))
	}
	return n
}

func (m *OracleResponsePacketData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequestID != 0 {
		n += 1 + sovTypes(uint64(m.RequestID))
	}
	if m.AnsCount != 0 {
		n += 1 + sovTypes(uint64(m.AnsCount))
	}
	if m.RequestTime != 0 {
		n += 1 + sovTypes(uint64(m.RequestTime))
	}
	if m.ResolveTime != 0 {
		n += 1 + sovTypes(uint64(m.ResolveTime))
	}
	if m.ResolveStatus != 0 {
		n += 1 + sovTypes(uint64(m.ResolveStatus))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ValidatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsActive {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Since)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRawRequestCount != 0 {
		n += 1 + sovTypes(uint64(m.MaxRawRequestCount))
	}
	if m.MaxAskCount != 0 {
		n += 1 + sovTypes(uint64(m.MaxAskCount))
	}
	if m.ExpirationBlockCount != 0 {
		n += 1 + sovTypes(uint64(m.ExpirationBlockCount))
	}
	if m.BaseRequestGas != 0 {
		n += 1 + sovTypes(uint64(m.BaseRequestGas))
	}
	if m.PerValidatorRequestGas != 0 {
		n += 1 + sovTypes(uint64(m.PerValidatorRequestGas))
	}
	if m.SamplingTryCount != 0 {
		n += 1 + sovTypes(uint64(m.SamplingTryCount))
	}
	if m.OracleRewardPercentage != 0 {
		n += 1 + sovTypes(uint64(m.OracleRewardPercentage))
	}
	if m.InactivePenaltyDuration != 0 {
		n += 1 + sovTypes(uint64(m.InactivePenaltyDuration))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRequestData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawReports = append(m.RawReports, RawReport{})
			if err := m.RawReports[len(m.RawReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = append(m.Executable[:0], dAtA[iNdEx:postIndex]...)
			if m.Executable == nil {
				m.Executable = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditDataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditDataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditDataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executable = append(m.Executable[:0], dAtA[iNdEx:postIndex]...)
			if m.Executable == nil {
				m.Executable = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditOracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditOracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditOracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddReporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddReporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddReporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveReporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveReporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveReporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = append(m.Reporter[:0], dAtA[iNdEx:postIndex]...)
			if m.Reporter == nil {
				m.Reporter = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleScript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleScript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleScript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCodeURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSourceID", wireType)
			}
			m.DataSourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSourceID |= DataSourceID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			m.ExternalID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalID |= ExternalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedValidators", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedValidators = append(m.RequestedValidators, make([]byte, postIndex-iNdEx))
			copy(m.RequestedValidators[len(m.RequestedValidators)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeight", wireType)
			}
			m.RequestHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRequests = append(m.RawRequests, RawRequest{})
			if err := m.RawRequests[len(m.RawRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = append(m.Validator[:0], dAtA[iNdEx:postIndex]...)
			if m.Validator == nil {
				m.Validator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBeforeResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InBeforeResolve = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawReports = append(m.RawReports, RawReport{})
			if err := m.RawReports[len(m.RawReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleRequestPacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestPacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestPacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleScriptID", wireType)
			}
			m.OracleScriptID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleScriptID |= OracleScriptID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calldata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calldata = append(m.Calldata[:0], dAtA[iNdEx:postIndex]...)
			if m.Calldata == nil {
				m.Calldata = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
			}
			m.AskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleResponsePacketData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleResponsePacketData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleResponsePacketData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= RequestID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsCount", wireType)
			}
			m.AnsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			m.RequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			m.ResolveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveStatus", wireType)
			}
			m.ResolveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolveStatus |= ResolveStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Since, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRawRequestCount", wireType)
			}
			m.MaxRawRequestCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRawRequestCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAskCount", wireType)
			}
			m.MaxAskCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAskCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationBlockCount", wireType)
			}
			m.ExpirationBlockCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationBlockCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRequestGas", wireType)
			}
			m.BaseRequestGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRequestGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerValidatorRequestGas", wireType)
			}
			m.PerValidatorRequestGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerValidatorRequestGas |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingTryCount", wireType)
			}
			m.SamplingTryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SamplingTryCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleRewardPercentage", wireType)
			}
			m.OracleRewardPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleRewardPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactivePenaltyDuration", wireType)
			}
			m.InactivePenaltyDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactivePenaltyDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
